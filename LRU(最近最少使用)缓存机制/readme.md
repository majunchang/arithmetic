运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和写入数据 put 。
获取数据 get(key) - 如果密钥 ( key ) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1 。
写入数据 put(key, value) - 如果密钥不存在，则写入数据。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据，从而为新数据留出空间。
进阶:
你是否可以在 O(1) 时间复杂度内完成这两种操作？


> 解读

> vue中keep-alive 内置组件使用了这种思想  具体见keep-alive
这其实应用了一个缓存淘汰策略LRU：

LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。

它的算法是这样子的
![](https://tva1.sinaimg.cn/large/007S8ZIlly1geksxbt06cj30xa0c7q2x.jpg)

1. 新数据从尾部插入到this.keys中；
2. 每当缓存命中（即缓存数据被访问），则将数据移到this.keys的尾部；
3. 当this.keys满的时候，将头部的数据丢弃；

LRU的核心思想是如果数据最近被访问过，那么将来被访问的几率也更高，所以我们将命中缓存的组件key重新插入到this.keys的尾部，这样一来，this.keys中越往头部的数据即将来被访问几率越低，所以当缓存数量达到最大值时，我们就删除将来被访问几率最低的数据，即this.keys中第一个缓存的组件。这也就之前加粗强调的已缓存组件中最久没有被访问的实例会被销毁掉的原因所在